name: CI/CD Pipeline

on:
  push:
    branches:
      - cicd
  pull_request:
    branches:
      - main

env:
  PYTHON_VERSION: '3.11'
  DOCKER_BUILDKIT: 1

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
      
      rabbitmq:
        image: rabbitmq:3-management-alpine
        env:
          RABBITMQ_DEFAULT_USER: admin
          RABBITMQ_DEFAULT_PASS: admin
        options: >-
          --health-cmd "rabbitmq-diagnostics ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5672:5672
      
      mongodb:
        image: mongo:7
        env:
          MONGO_INITDB_ROOT_USERNAME: admin
          MONGO_INITDB_ROOT_PASSWORD: admin
        options: >-
          --health-cmd "mongosh --eval 'db.adminCommand(\"ping\")'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 27017:27017

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install shared package
        working-directory: ./shared
        run: |
          pip install --upgrade pip
          pip install -e .

      - name: Install service dependencies
        run: |
          pip install -r auth-service/requirements.txt -r auth-service/requirements-dev.txt
          pip install -r order-service/requirements.txt -r order-service/requirements-dev.txt
          pip install -r product-service/requirements.txt -r product-service/requirements-dev.txt
          pip install -r notification-service/requirements.txt -r notification-service/requirements-dev.txt

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Run auth-service tests
        working-directory: ./auth-service
        env:
          APP_NAME: TheOne
          ENVIRONMENT: test
          DEBUG: "false"
          LOG_LEVEL: INFO
          SERVICE_NAME: auth-service
          JSON_OUTPUT: "false"
          LOG_FILE: ""
          JWT_SECRET_KEY: your-secret-key-change-in-test
          JWT_ALGORITHM: HS256
          ACCESS_TOKEN_EXPIRE_MINUTES: 30
          REFRESH_TOKEN_EXPIRE_DAYS: 7
          POSTGRES_AUTH_URL: postgresql://postgres:postgres@localhost:5432/theone_auth_db
          POSTGRES_AUTH_POOL_SIZE: 5
          POSTGRES_AUTH_MAX_OVERFLOW: 10
          POSTGRES_AUTH_POOL_TIMEOUT: 30  
          REDIS_URL: redis://localhost:6379
          REDIS_DECODE_RESPONSES: "true"
          REDIS_SOCKET_TIMEOUT: 5
          REDIS_SOCKET_CONNECT_TIMEOUT: 5
        run: |
          # Create test database
          PGPASSWORD=postgres psql -h localhost -U postgres -c "CREATE DATABASE theone_auth_db;" || true
          # Run migrations
          alembic upgrade head || true
          # Run tests
          pytest

      - name: Run order-service tests
        working-directory: ./order-service
        env:
          APP_NAME: TheOne
          ENVIRONMENT: test
          DEBUG: "false"
          LOG_LEVEL: INFO
          SERVICE_NAME: order-service
          JSON_OUTPUT: "false"
          LOG_FILE: ""
          JWT_SECRET_KEY: your-secret-key-change-in-test
          JWT_ALGORITHM: HS256
          ACCESS_TOKEN_EXPIRE_MINUTES: 30
          REFRESH_TOKEN_EXPIRE_DAYS: 7
          POSTGRES_ORDER_URL: postgresql://postgres:postgres@localhost:5432/theone_order_db
          POSTGRES_ORDER_POOL_SIZE: 5
          POSTGRES_ORDER_MAX_OVERFLOW: 10
          POSTGRES_ORDER_POOL_TIMEOUT: 30
          REDIS_URL: redis://localhost:6379
          REDIS_DECODE_RESPONSES: "true"
          REDIS_SOCKET_TIMEOUT: 5
          REDIS_SOCKET_CONNECT_TIMEOUT: 5
          RABBITMQ_URL: amqp://admin:admin@localhost:5672/
          RABBITMQ_EXCHANGE: ecommerce.events
          RABBITMQ_QUEUE_PREFIX: theone
          RABBITMQ_PREFETCH_COUNT: 10
        run: |
          # Create test database
          PGPASSWORD=postgres psql -h localhost -U postgres -c "CREATE DATABASE theone_order_db;" || true
          # Run migrations
          alembic upgrade head || true
          # Run tests
          pytest

      - name: Run product-service tests
        working-directory: ./product-service
        env:
          APP_NAME: TheOne
          ENVIRONMENT: test
          DEBUG: "false"
          LOG_LEVEL: INFO
          SERVICE_NAME: product-service
          JSON_OUTPUT: "false"
          LOG_FILE: ""
          JWT_SECRET_KEY: your-secret-key-change-in-test
          JWT_ALGORITHM: HS256
          ACCESS_TOKEN_EXPIRE_MINUTES: 30
          REFRESH_TOKEN_EXPIRE_DAYS: 7
          MONGODB_URL: mongodb://admin:admin@localhost:27017/theone_db?authSource=admin
          MONGODB_DATABASE: theone_db
          REDIS_URL: redis://localhost:6379
          REDIS_DECODE_RESPONSES: "true"
          REDIS_SOCKET_TIMEOUT: 5
          REDIS_SOCKET_CONNECT_TIMEOUT: 5
          RABBITMQ_URL: amqp://admin:admin@localhost:5672/
          RABBITMQ_EXCHANGE: ecommerce.events
          RABBITMQ_QUEUE_PREFIX: theone
          RABBITMQ_PREFETCH_COUNT: 10
        run: |
          # Run tests
          pytest

      - name: Run notification-service tests
        working-directory: ./notification-service
        env:
          APP_NAME: TheOne
          ENVIRONMENT: test
          DEBUG: "false"
          LOG_LEVEL: INFO
          SERVICE_NAME: notification-service
          JSON_OUTPUT: "false"
          LOG_FILE: ""
          JWT_SECRET_KEY: your-secret-key-change-in-test
          JWT_ALGORITHM: HS256
          ACCESS_TOKEN_EXPIRE_MINUTES: 30
          REFRESH_TOKEN_EXPIRE_DAYS: 7
          REDIS_URL: redis://localhost:6379
          REDIS_DECODE_RESPONSES: "true"
          REDIS_SOCKET_TIMEOUT: 5
          REDIS_SOCKET_CONNECT_TIMEOUT: 5
          RABBITMQ_URL: amqp://admin:admin@localhost:5672/
          RABBITMQ_EXCHANGE: ecommerce.events
          RABBITMQ_QUEUE_PREFIX: notification-service
          RABBITMQ_PREFETCH_COUNT: 10
        run: |
          # Run tests
          pytest

  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/cicd'
    permissions:
      contents: read
      packages: write   

    strategy:
      matrix:
        service:
          - auth-service
          - notification-service
          - order-service
          - product-service

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      # just for testing purposes
      - name: Create GCP credentials file
        run: |
          mkdir -p shared/shared
          echo '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}' > shared/shared/gcp-credentials.json
          chmod 600 shared/shared/gcp-credentials.json

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ matrix.service }}/Dockerfile
          push: false
          tags: theone-${{ matrix.service }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Login to Container Registry (GITHUB_TOKEN)
        if: vars.USE_CR_PAT != 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Login to Container Registry (PAT)
        if: vars.USE_CR_PAT == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ vars.GHCR_USERNAME || github.actor }}
          password: ${{ secrets.CR_PAT }}
      
      - name: Push Docker image for ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ matrix.service }}/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository }}/${{ matrix.service }}:${{ github.sha }}
            ghcr.io/${{ github.repository }}/${{ matrix.service }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-notification-worker:
    name: Build Notification Worker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/cicd'
    permissions:
      contents: read
      packages: write   

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create GCP credentials file
        run: |
          mkdir -p shared/shared
          echo '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}' > shared/shared/gcp-credentials.json
          chmod 600 shared/shared/gcp-credentials.json

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry (GITHUB_TOKEN)
        if: vars.USE_CR_PAT != 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Login to Container Registry (PAT)
        if: vars.USE_CR_PAT == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ vars.GHCR_USERNAME || github.actor }}
          password: ${{ secrets.CR_PAT }}

      - name: Build and push Docker image for notification-worker
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./notification-service/Dockerfile.worker
          push: true
          tags: |
            ghcr.io/${{ github.repository }}/notification-worker:${{ github.sha }}
            ghcr.io/${{ github.repository }}/notification-worker:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  lint:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install linting tools
        run: |
          pip install --upgrade pip
          pip install flake8 black isort mypy

      - name: Check code formatting with black
        run: |
          black --check --diff auth-service/ order-service/ product-service/ notification-service/ shared/ || true

      - name: Check import sorting with isort
        run: |
          isort --check-only --diff auth-service/ order-service/ product-service/ notification-service/ shared/ || true

      - name: Lint with flake8
        run: |
          flake8 auth-service/ order-service/ product-service/ notification-service/ shared/ --count --select=E9,F63,F7,F82 --show-source --statistics || true
          flake8 auth-service/ order-service/ product-service/ notification-service/ shared/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics || true

  deploy:
    name: Deploy to Production (GCP e2-micro)
    runs-on: ubuntu-latest
    needs: [build, build-notification-worker]
    if: github.event_name == 'push' && github.ref == 'refs/heads/cicd'
    # environment:
    #   name: production
    #   url: http://${{ secrets.GCP_VM_IP }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.GCP_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.GCP_VM_IP }} >> ~/.ssh/known_hosts

      - name: Create .env file
        run: |
          cat > .env.prod << EOF
          # GitHub Container Registry
          GITHUB_REPOSITORY=${{ github.repository }}
          
          # GCP Configuration
          GCP_PROJECT_ID=${{ secrets.GCP_PROJECT_ID }}
          GCP_SECRET_NAMES=${{ secrets.GCP_SECRET_NAMES }}
          GCP_CREDENTIALS_PATH=/root/theone/gcp-credentials.json
          
          # PostgreSQL Configuration
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=postgres
          POSTGRES_AUTH_DB=theone_auth_db
          POSTGRES_ORDER_DB=theone_order_db
          
          # MongoDB Configuration
          MONGO_ROOT_USERNAME=${{ secrets.MONGO_ROOT_USERNAME }}
          MONGO_ROOT_PASSWORD=${{ secrets.MONGO_ROOT_PASSWORD }}
          MONGODB_DATABASE=theone_db
          
          # Redis Configuration
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          
          # RabbitMQ Configuration
          RABBITMQ_USER=${{ secrets.RABBITMQ_USER }}
          RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD }}
          EOF

      - name: Copy files to server
        run: |
          # Create directory structure
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }} "mkdir -p ~/theone/nginx/conf.d"
          
          # Copy deployment files
          scp -i ~/.ssh/id_rsa docker-compose.prod.yml ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }}:~/theone/
          scp -i ~/.ssh/id_rsa .env.prod ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }}:~/theone/.env
          scp -i ~/.ssh/id_rsa nginx/nginx.conf ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }}:~/theone/nginx/
          scp -i ~/.ssh/id_rsa nginx/conf.d/default.conf ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }}:~/theone/nginx/conf.d/

      - name: Setup GCP credentials on server
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }} << 'EOF'
            set -e
            cd ~/theone
            
            # Create GCP credentials file from secret
            echo '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}' > gcp-credentials.json
            chmod 600 gcp-credentials.json
          EOF

      - name: Install Docker on server if not present
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }} << 'EOF'
            set -e
            
            # Check if docker is already installed
            if command -v docker &> /dev/null; then
              echo "Docker is already installed"
              docker --version
              exit 0
            fi
            
            echo "Docker not found. Installing Docker..."
            
            # Update package list
            sudo apt-get update
            
            # Install prerequisites
            sudo apt-get install -y \
              ca-certificates \
              curl \
              gnupg \
              lsb-release
            
            # Add Docker's official GPG key
            sudo install -m 0755 -d /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            sudo chmod a+r /etc/apt/keyrings/docker.gpg
            
            # Set up the repository
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
              $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
              sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Install Docker Engine
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            
            # Add current user to docker group
            sudo usermod -aG docker $USER
            
            # Start and enable Docker
            sudo systemctl start docker
            sudo systemctl enable docker
            
            echo "Docker installed successfully!"
            docker --version
          EOF

      - name: Deploy to GCP VM
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }} << 'EOF'
            set -e
            
            # Set up PATH for non-interactive shell to find docker
            export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            
            # Use sg to run commands with docker group (handles new group membership)
            run_docker() {
              if groups | grep -q docker; then
                "$@"
              else
                sg docker -c "$*"
              fi
            }
            
            cd ~/theone
            
            # Login to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | run_docker docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Pull latest images
            run_docker docker compose -f docker-compose.prod.yml pull
            
            # Stop and remove old containers (keep volumes)
            run_docker docker compose -f docker-compose.prod.yml down || true
            
            # Start infrastructure services first
            run_docker docker compose -f docker-compose.prod.yml up -d postgres mongodb redis rabbitmq
            
            # Wait for databases to be healthy
            echo "Waiting for databases to be ready..."
            sleep 20
            
            # Initialize PostgreSQL databases if they don't exist
            run_docker docker exec postgres psql -U $POSTGRES_USER -tc "SELECT 1 FROM pg_database WHERE datname = 'theone_auth_db'" | grep -q 1 || \
              run_docker docker exec postgres psql -U $POSTGRES_USER -c "CREATE DATABASE theone_auth_db;"
            
            run_docker docker exec postgres psql -U $POSTGRES_USER -tc "SELECT 1 FROM pg_database WHERE datname = 'theone_order_db'" | grep -q 1 || \
              run_docker docker exec postgres psql -U $POSTGRES_USER -c "CREATE DATABASE theone_order_db;"
            
            echo "Databases initialized successfully"
            
            # Start application services
            run_docker docker compose -f docker-compose.prod.yml up -d auth-service product-service order-service notification-service notification-worker
            
            # Wait for services to be ready
            echo "Waiting for services to be ready..."
            sleep 15
            
            # Run database migrations for auth-service
            echo "Running auth-service migrations..."
            run_docker docker exec auth-service alembic upgrade head || echo "Migration failed or already applied"
            
            # Run database migrations for order-service
            echo "Running order-service migrations..."
            run_docker docker exec order-service alembic upgrade head || echo "Migration failed or already applied"
            
            # Seed initial data for auth-service (roles)
            echo "Seeding auth-service roles..."
            run_docker docker exec auth-service python scripts/seed_roles.py || echo "Seeding failed or already done"
            
            # Start nginx
            run_docker docker compose -f docker-compose.prod.yml up -d nginx
            
            # Clean up old images
            run_docker docker image prune -af --filter "until=24h" || true
            
            # Show running containers
            echo "Deployment complete! Running containers:"
            run_docker docker compose -f docker-compose.prod.yml ps
          EOF

      - name: Verify deployment
        run: |
          echo "Waiting for services to stabilize..."
          sleep 15
          
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }} << 'EOF'
            set -e
            
            # Set up PATH for non-interactive shell to find docker
            export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            
            # Use sg to run commands with docker group (handles new group membership)
            run_docker() {
              if groups | grep -q docker; then
                "$@"
              else
                sg docker -c "$*"
              fi
            }
            
            cd ~/theone
            
            echo "=== Container Status ==="
            run_docker docker compose -f docker-compose.prod.yml ps
            
            echo -e "\n=== Health Check ==="
            curl -f http://localhost/health || exit 1
            echo "âœ“ Health check passed"
            
            echo -e "\n=== Service Logs (last 20 lines) ==="
            run_docker docker compose -f docker-compose.prod.yml logs --tail=20 auth-service
            run_docker docker compose -f docker-compose.prod.yml logs --tail=20 product-service
            run_docker docker compose -f docker-compose.prod.yml logs --tail=20 order-service
            run_docker docker compose -f docker-compose.prod.yml logs --tail=20 notification-service
            
            echo -e "\n=== Deployment verified successfully! ==="
          EOF
