name: CI/CD Pipeline

on:
  push:
    branches:
      - cicd
  pull_request:
    branches:
      - main

env:
  PYTHON_VERSION: '3.11'
  DOCKER_BUILDKIT: 1

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install shared package
        working-directory: ./shared
        run: |
          pip install --upgrade pip
          pip install -e .

      - name: Install service dependencies
        run: |
          pip install -r auth-service/requirements.txt -r auth-service/requirements-dev.txt

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Run auth-service tests
        working-directory: ./auth-service
        env:
          APP_NAME: TheOne
          ENVIRONMENT: test
          DEBUG: "false"
          LOG_LEVEL: INFO
          SERVICE_NAME: auth-service
          JSON_OUTPUT: "false"
          LOG_FILE: ""
          JWT_SECRET_KEY: your-secret-key-change-in-test
          JWT_ALGORITHM: HS256
          ACCESS_TOKEN_EXPIRE_MINUTES: 30
          REFRESH_TOKEN_EXPIRE_DAYS: 7
          POSTGRES_AUTH_URL: postgresql://postgres:postgres@localhost:5432/theone_auth_db
          POSTGRES_AUTH_POOL_SIZE: 5
          POSTGRES_AUTH_MAX_OVERFLOW: 10
          POSTGRES_AUTH_POOL_TIMEOUT: 30  
          REDIS_URL: redis://localhost:6379
          REDIS_DECODE_RESPONSES: "true"
          REDIS_SOCKET_TIMEOUT: 5
          REDIS_SOCKET_CONNECT_TIMEOUT: 5
        run: |
          # Create test database
          PGPASSWORD=postgres psql -h localhost -U postgres -c "CREATE DATABASE theone_auth_db;" || true
          # Run migrations
          alembic upgrade head || true
          # Run tests
          pytest

  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/cicd'
    permissions:
      contents: read
      packages: write   

    strategy:
      matrix:
        service:
          - auth-service
          # - notification-service
          # - order-service
          # - product-service

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      # just for testin
      - name: Create GCP credentials file
        run: |
          mkdir -p shared/shared
          echo '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}' > shared/shared/gcp-credentials.json
          chmod 600 shared/shared/gcp-credentials.json

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ matrix.service }}/Dockerfile
          push: false
          tags: theone-${{ matrix.service }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Login to Container Registry (GITHUB_TOKEN)
        if: vars.USE_CR_PAT != 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Login to Container Registry (PAT)
        if: vars.USE_CR_PAT == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ vars.GHCR_USERNAME || github.actor }}
          password: ${{ secrets.CR_PAT }}
      
      - name: Push Docker image for ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ matrix.service }}/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository }}/${{ matrix.service }}:${{ github.sha }}
            ghcr.io/${{ github.repository }}/${{ matrix.service }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # build-notification-worker:
  #   name: Build Notification Worker Image
  #   runs-on: ubuntu-latest
  #   needs: test
  #   if: github.event_name == 'push' && github.ref == 'refs/heads/cicd'
  #   permissions:
  #     contents: read
  #     packages: write   

  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Create GCP credentials file
  #       run: |
  #         mkdir -p shared/shared
  #         echo '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}' > shared/shared/gcp-credentials.json
  #         chmod 600 shared/shared/gcp-credentials.json

  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3

  #     - name: Login to Container Registry (GITHUB_TOKEN)
  #       if: vars.USE_CR_PAT != 'true'
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ghcr.io
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}

  #     - name: Login to Container Registry (PAT)
  #       if: vars.USE_CR_PAT == 'true'
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ghcr.io
  #         username: ${{ vars.GHCR_USERNAME || github.actor }}
  #         password: ${{ secrets.CR_PAT }}

  #     - name: Build and push Docker image for notification-worker
  #       uses: docker/build-push-action@v5
  #       with:
  #         context: .
  #         file: ./notification-service/Dockerfile.worker
  #         push: true
  #         tags: |
  #           ghcr.io/${{ github.repository }}/notification-worker:${{ github.sha }}
  #           ghcr.io/${{ github.repository }}/notification-worker:latest
  #         cache-from: type=gha
  #         cache-to: type=gha,mode=max

  lint:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install linting tools
        run: |
          pip install --upgrade pip
          pip install flake8 black isort mypy

      - name: Check code formatting with black
        run: |
          black --check --diff auth-service/ shared/ || true

      - name: Check import sorting with isort
        run: |
          isort --check-only --diff auth-service/ shared/ || true

      - name: Lint with flake8
        run: |
          flake8 auth-service/ shared/ --count --select=E9,F63,F7,F82 --show-source --statistics || true
          flake8 auth-service/ shared/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics || true

  deploy:
    name: Deploy to Production (GCP e2-micro)
    runs-on: ubuntu-latest
    # needs: [build, build-notification-worker]
    needs: [build]
    if: github.event_name == 'push' && github.ref == 'refs/heads/cicd'
    # environment:
    #   name: production
    #   url: http://${{ secrets.GCP_VM_IP }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          
          if [ -z "${{ secrets.GCP_SSH_PRIVATE_KEY }}" ]; then
            echo "Error: GCP_SSH_PRIVATE_KEY secret is not set"
            exit 1
          fi
          
          if [ -z "${{ secrets.GCP_VM_IP }}" ]; then
            echo "Error: GCP_VM_IP secret is not set"
            exit 1
          fi
          
          echo "${{ secrets.GCP_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          echo "Scanning SSH host keys for ${{ secrets.GCP_VM_IP }}..."
          if ! ssh-keyscan -H -T 10 ${{ secrets.GCP_VM_IP }} >> ~/.ssh/known_hosts 2>&1; then
            echo "Warning: ssh-keyscan failed, setting up SSH config to skip strict host checking"
            cat > ~/.ssh/config << 'SSHCONFIG'
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
          SSHCONFIG
            chmod 600 ~/.ssh/config
          fi
          
          echo "SSH setup complete"

      - name: Create .env file
        run: |
          cat > .env.prod << EOF
          # GitHub Container Registry
          GITHUB_REPOSITORY=${{ github.repository }}
          
          # GCP Configuration
          GCP_PROJECT_ID=${{ secrets.GCP_PROJECT_ID }}
          GCP_SECRET_NAMES=${{ secrets.GCP_SECRET_NAMES }}
          GCP_CREDENTIALS_PATH=/root/theone/gcp-credentials.json
          
          # PostgreSQL Configuration
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=postgres
          POSTGRES_AUTH_DB=theone_auth_db
          
          # Redis Configuration
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          EOF

      - name: Copy files to server
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }} "mkdir -p ~/theone/nginx/conf.d"
          
          # Copy deployment files
          scp -i ~/.ssh/id_rsa docker-compose.prod.yml ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }}:~/theone/
          scp -i ~/.ssh/id_rsa .env.prod ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }}:~/theone/.env
          scp -i ~/.ssh/id_rsa nginx/nginx.conf ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }}:~/theone/nginx/
          scp -i ~/.ssh/id_rsa nginx/conf.d/default.conf ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }}:~/theone/nginx/conf.d/

      - name: Setup GCP credentials on server
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }} << 'EOF'
            set -e
            cd ~/theone
            
            # Create GCP credentials file from secret
            echo '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}' > gcp-credentials.json
            chmod 600 gcp-credentials.json
          EOF

      - name: Install Docker on server if not present
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }} << 'EOF'
            # set -e
            
            # Check if docker is already installed
            if command -v docker &> /dev/null; then
              echo "Docker is already installed"
              docker --version
              exit 0
            fi
            
            echo "Docker not found. Installing Docker..."
            
            # Update package list
            sudo apt-get update
            
            # Install prerequisites
            sudo apt-get install -y \
              ca-certificates \
              curl \
              gnupg \
              lsb-release
            
            # Add Docker's official GPG key
            sudo install -m 0755 -d /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            sudo chmod a+r /etc/apt/keyrings/docker.gpg
            
            # Set up the repository
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
              $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
              sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Install Docker Engine
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            
            # Add current user to docker group
            sudo usermod -aG docker $USER
            
            # Start and enable Docker
            sudo systemctl start docker
            sudo systemctl enable docker
            
            echo "Docker installed successfully!"
            docker --version
          EOF

      - name: Deploy to GCP VM
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }} << 'EOF'
            set -e
            
            # Set up PATH for non-interactive shell to find docker
            export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            
            cd ~/theone
            
            # Load environment variables from .env file
            if [ -f .env ]; then
              set -a
              source .env
              set +a
            fi
            
            # Store critical env vars before using sudo (sudo doesn't preserve environment)
            PG_USER="${POSTGRES_USER:-postgres}"
            echo "Using PostgreSQL user: $PG_USER"
            
            # Function to retry commands
            retry_command() {
              local max_attempts=3
              local attempt=1
              local delay=10
              
              while [ $attempt -le $max_attempts ]; do
                echo "Attempt $attempt/$max_attempts: $*"
                if "$@"; then
                  return 0
                fi
                
                if [ $attempt -lt $max_attempts ]; then
                  echo "Command failed, waiting ${delay}s before retry..."
                  sleep $delay
                  delay=$((delay * 2))
                fi
                attempt=$((attempt + 1))
              done
              
              echo "Command failed after $max_attempts attempts"
              return 1
            }
            
            # Login to GitHub Container Registry with retry (use sudo for docker commands)
            echo "Logging into GitHub Container Registry..."
            echo "${{ secrets.GITHUB_TOKEN }}" | retry_command sudo docker login ghcr.io -u ${{ github.actor }} --password-stdin || {
              echo "Warning: Failed to login to GHCR after retries. Deployment may use cached images."
            }
            
            # Stop and remove old containers (keep volumes)
            sudo docker compose -f docker-compose.prod.yml down || true
            
            # Pull only application images from GHCR (infrastructure images will be pulled when starting)
            echo "Pulling application images from GitHub Container Registry..."
            
            # Skip pulls if network is having issues - will use existing images or pull during compose up
            if retry_command sudo docker pull ghcr.io/${GITHUB_REPOSITORY}/auth-service:latest; then
              echo "✓ auth-service image updated"
            else
              echo "⚠ Using existing auth-service image (pull failed)"
            fi
            
            # Start infrastructure services first
            sudo docker compose -f docker-compose.prod.yml up -d postgres redis
            
            # Wait for databases to be ready
            echo "Waiting for databases to be ready..."
            sleep 30
            
            # Check if containers are running (not strict health checks due to resource constraints on e2-micro)
            echo "Checking if services are running..."
            for i in {1..12}; do
              echo "Check attempt $i/12..."
              
              # Check if containers are running
              POSTGRES_STATUS=$(sudo docker inspect --format='{{.State.Status}}' postgres 2>/dev/null || echo "not found")
              REDIS_STATUS=$(sudo docker inspect --format='{{.State.Status}}' redis 2>/dev/null || echo "not found")
              
              echo "  Postgres: $POSTGRES_STATUS"
              echo "  Redis: $REDIS_STATUS"
              
              # Count running services
              RUNNING=0
              [ "$POSTGRES_STATUS" = "running" ] && RUNNING=$((RUNNING + 1))
              [ "$REDIS_STATUS" = "running" ] && RUNNING=$((RUNNING + 1))
              
              echo "  $RUNNING/2 services are running"
              
              if [ $RUNNING -eq 2 ]; then
                echo "All infrastructure services are running, continuing..."
                break
              fi
              
              if [ $i -eq 12 ]; then
                echo "WARNING: Not all services started properly. Continuing anyway due to resource constraints..."
                sudo docker ps -a
              fi
              
              sleep 10
            done
            
            # Initialize PostgreSQL databases if they don't exist
            sudo docker exec postgres psql -U "$PG_USER" -tc "SELECT 1 FROM pg_database WHERE datname = 'theone_auth_db'" | grep -q 1 || \
              sudo docker exec postgres psql -U "$PG_USER" -c "CREATE DATABASE theone_auth_db;"
            
            echo "Database initialized successfully"
            
            # Start application services and nginx
            sudo docker compose -f docker-compose.prod.yml up -d auth-service nginx
            
            # Wait for services to be ready
            echo "Waiting for services to be ready..."
            sleep 15
            
            # Run database migrations for auth-service
            echo "Running auth-service migrations..."
            sudo docker exec auth-service alembic upgrade head || echo "Migration failed or already applied"
            
            # Seed initial data for auth-service (roles)
            echo "Seeding auth-service roles..."
            sudo docker exec auth-service python scripts/seed_roles.py || echo "Seeding failed or already done"
            
            # Clean up old images
            sudo docker image prune -af --filter "until=24h" || true
            
            # Show running containers
            echo "Deployment complete! Running containers:"
            sudo docker compose -f docker-compose.prod.yml ps
          EOF

      - name: Verify deployment
        run: |
          echo "Waiting for services to stabilize..."
          sleep 15
          
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_SSH_USER }}@${{ secrets.GCP_VM_IP }} << 'EOF'
            set -e
            
            # Set up PATH for non-interactive shell to find docker
            export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            
            cd ~/theone
            
            echo "=== Container Status ==="
            sudo docker compose -f docker-compose.prod.yml ps
            
            echo -e "\n=== Service Logs (last 20 lines) ==="
            sudo docker compose -f docker-compose.prod.yml logs --tail=20 auth-service
            sudo docker compose -f docker-compose.prod.yml logs --tail=20 nginx

            echo -e "\n=== Deployment verified successfully! ==="
          EOF
